/// Top-level rule.
<file> ::= <preamble> { <expr> | ";" }

<preamble> ::= [ <module-declaration> ] { <import-declaration> | ";" }

<module-declaration> ::= "module" IDENTIFIER
<import-declaration> ::= "import" IDENTIFIER

/// Expression.
<expr>     ::= <expr-decl>
             | <expr-if>
             | <expr-for>
             | <expr-while>
             | <expr-block>
             | <expr-lambda>
             | <expr-call>
             | <expr-cast>
             | <expr-subs>
             | <expr-paren>
             | <expr-return>
             | <expr-literal>
             | <expr-binary>
             | <expr-prefix>
             | <expr-primary>
             | EXPR

/// Declarations.
<expr-decl>      ::= [ EXPORT ] [ EXTERN ] IDENTIFIER <decl-rest>
<decl-rest>      ::= <decl-object> | <decl-type>
<decl-object>    ::= ":" <decl-typed> | "::" <expr>
<decl-type>      ::= ":>" <type>
<decl-typed>     ::= <type> [ "=" <expr> ]
                   | <type-function> [ <function-body> ]

/// Other expressions.
<expr-if>        ::= IF <expr> <expr> [ ELSE <expr> ]
<expr-while>     ::= WHILE <expr> <expr>
<expr-for>       ::= FOR <expr> [ "," ] <expr> [ "," ] <expr> <expr>
<expr-block>     ::= "{" { <expr> } "}"
<expr-lambda>    ::= <type-function> <function-body>
<expr-call>      ::= <expr> "(" { <expr> [ "," ] } ")"
<expr-cast>      ::= <expr> AS <type>
<expr-subs>      ::= <expr> "[" <expr> "]"
<expr-paren>     ::= "(" <expr> ")"
<expr-return>    ::= RETURN [ <expr> ]
<expr-literal>   ::= "[" { <expr> [ "," ] } "]"
<expr-prefix>    ::= <prefix> <expr>
<expr-binary>    ::= <expr> <binary> <expr>
<expr-primary>   ::= NUMBER | IDENTIFIER

/// Types.
///
/// Note that this grammar is technically incorrect as it doesnâ€™t
/// take precedence into account at all. For more information on
/// type precedence, see the comment in ParseType().
<type>           ::= <type-quals> <type-base> <type-rest> | "(" <type> ")"
<type-quals>     ::= { "@" | "&" }
<type-base>      ::= <type-struct> | <type-builtin> | IDENTIFIER | INT_TYPE
<type-struct>    ::= TYPE <struct-body>
<type-builtin>   ::= INTEGER | BYTE | BOOL | VOID
<type-rest>      ::= { <type-arr-sz> | <type-signature>  }
<type-arr-sz>    ::= "[" <expr> "]"
<type-signature> ::= "(" <param-decls> ")" <func-attrs>
<param-decls>    ::= { <param-decl> [ "," ]  }
<param-decl>     ::= [ IDENTIFIER ] ":" <type>
<func-attrs>     ::= /// All function attributes

/// Miscellaneous.
<type-function>  ::= <type-base> <type-signature>
<function-body>  ::= "=" <expr> | <expr-block>
<struct-body>    ::= "{" { <param-decl> } "}"
<binary>         ::= /// All binary operators
<prefix>         ::= /// All unary prefix operators