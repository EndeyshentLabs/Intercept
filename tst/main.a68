#!/usr/bin/a68g

PROC platform is windows = BOOL: get env ("WINDIR") NE "";
STRING platform dir sep   = (platform is windows | "\"     | "/"    );
STRING executable suffix  = (platform is windows | ".exe"  | ""     );
STRING executable prefix  = (platform is windows | ""      | "./"   );
STRING calling convention = (platform is windows | "MSWIN" | "LINUX");

CO Statistics CO
INT tests run := 0;
INT tests failed := 0;
INT tests errored := 0;
INT tests skipped := 0;

CO Get the exit code of a program. CO
PROC wexitstatus = (INT status) INT: (platform is windows | status | ABS ((BIN status SHR 8) AND BIN 255));

CO Helper because system() returns the exit status, not the exit code CO
PROC sh = (STRING cmd) INT: (platform is windows | system(cmd) | wexitstatus (system (cmd)));

PROC string to number = (STRING s) INT: BEGIN
  INT out := 0;
  FOR index FROM LWB s TO UPB s DO
    CHAR c = s[index];
    IF NOT is digit (c) THEN
      print(("ERROR!  Expected digit but got ", c, new line));
      stop
    FI;
    INT tmp := ABS c;
    tmp -:= 48;
    out *:= 10;
    out +:= tmp
  OD;
  out
END;

PROC compare expected =
(INT status,
 STRING output,
 INT actual status,
 REF STRING actual output
) BOOL:
BEGIN
  BOOL retval := TRUE;
  CO open out.txt, compare contents with `output` CO
  FILE out;
  IF open (out, "out.txt", stand in channel) /= 0 THEN
    print(("ERROR: Could not open 'out.txt'", new line));
    stop
  FI;

  on logical file end (out, (REF FILE f) BOOL: past);
  STRING str;
  DO
    get(out, str);
    actual output +:= str;
    actual output +:= new line char;
    new line (out)
  UNTIL end of file (out) OD;

  past: SKIP;

  IF actual output /= output THEN
    retval := FALSE;
    return
  FI;

  close (out);

  IF actual status /= status
  THEN
    retval := FALSE;
    return
  FI;

  return: retval
END;

CO Compile a test and check if it passes CO
PROC compile and test = (
  STRING file name, 
  INT return value, 
  STRING output, 
  BOOL expect error,
  BOOL optimise
) VOID:
BEGIN
  tests run +:= 1;

  CO Compile the program to ASM CO
  IF sh(".." + platform dir sep + "bld" + platform dir sep + "func -o test.S " 
             + (optimise | " -O " | "") 
             + "-cc " + calling convention + " "
             + file name) /= 0 THEN
    IF expect error THEN
      print(((optimise | "SUCCESS! (optimised)     --  " | "SUCCESS!                 --  "), file name, new line))
    ELSE
      print(((optimise | "ERRORED! (optimised)     --  " | "ERRORED!                 --  "), file name, new line));
      tests errored +:= 1
    FI;
    GO TO return
  FI;

  CO Assemble it CO
  IF sh("gcc test.S -o test" + executable suffix) /= 0 THEN
    print(((optimise | "ERRORED! (optimised)     --  " | "ERRORED!                 --  "), file name, new line));
    tests errored +:= 1;
    GO TO return
  FI;

  CO If the test should error, then we shouldnâ€™t even get here CO
  IF expect error THEN
    print(((optimise | "FAILED!  (optimised)     --  " | "FAILED!                  --  "), file name, new line));    
    print(("    Expected error, but test compiled successfully", new line));
    tests failed +:= 1;
    GO TO return
  FI;

  INT actual return value := sh(executable prefix + "test" + executable suffix + " > out.txt");
  STRING actual output := "";

  IF compare expected (return value, output, actual return value, actual output)
  THEN
    print(((optimise | "SUCCESS! (optimised)     --  " | "SUCCESS!                 --  "), file name, new line))
  ELSE
    print(((optimise | "FAILED! (optimised)      --  " | "FAILED!                  --  "), file name, new line));
    printf(($"Expected exit code " g(0) ", but got " g(0)l$, return value, actual return value));
    print(("=== EXPECTED OUTPUT ===", new line, output,        "===", new line));
    print(("=== GOT OUTPUT ===",      new line, actual output, "===", new line));
    tests failed +:= 1
  FI;

  return: SKIP
END;

PROC run test = (STRING file name) VOID:
BEGIN
  FILE f;
  IF open(f, file name, stand in channel) /= 0 THEN
    print(("ERROR!  Could not open test file ", file name, new line));
    stop
  FI;

  on logical file end (f, (REF FILE unused) BOOL: 
  BEGIN
    print(("ERROR! Test file ", file name, " does not contain a valid test!", new line));
    stop
  END);

  CO Save initial file contents as expected output. CO

  STRING str;

  CO Read first line as status return value CO
  get(f, (str, new line));

  IF UPB str < 3 THEN
    print(("ERROR!  First line not even long enough to contain return status.", new line));
    stop
  FI;

  IF str[1] /= REPR 59 THEN
    print(("ERROR!  First line does not start with comment!.", new line));
    stop
  FI;  

  CO Cut off comment delimiters CO
  str := str[3..];

  CO Check for special strings CO
  IF str EQ "SKIP" THEN
    print(("SKIPPED!                 --  ", file name, new line));
    print(("SKIPPED! (optimised)     --  ", file name, new line));
    tests skipped +:= 1;
    GO TO return
  FI;

  BOOL expect error := FALSE;
  IF str EQ "ERROR" THEN     
    expect error := TRUE;
    get (f, (str, new line));
    str := str[3..]
  FI; 

  CO Convert string into a number CO
  INT return value = string to number(str);

  CO Collect expected stdout... CO
  STRING output;
  WHILE get(f, (str, new line)); str /= "" DO
    str := str[3..];
    output +:= str;
    output +:= new line char
  OD;

  CO Close the file CO
  close (f);

  CO Compile program CO
  compile and test (file name, return value, output, expect error, FALSE);
  compile and test (file name, return value, output, expect error, TRUE);

  return: SKIP
END;

[] STRING tests = get directory ("tests");

CO Run tests CO
FOR index FROM LWB tests TO UPB tests DO
  IF file is regular ("tests/" + tests[index]) THEN
    run test ("tests/" + tests[index])
  FI
OD;

CO Print summary CO 
printf (($"SUMMARY:" l
          "    Tests run:     " g(0) l
          "    Tests failed:  " g(0) l
          "    Tests errored: " g(0) l
          "    Tests skipped: " g(0) l$,
          tests run, tests failed, tests errored, tests skipped))
